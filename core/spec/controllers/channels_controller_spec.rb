require 'spec_helper'

describe ChannelsController do
  render_views

  let (:user) { create :user }
  let (:nonnda_user) { create :user, agrees_tos: false }

  let (:f1) {create :fact, created_by: user.graph_user}
  let (:f2) {create :fact, created_by: user.graph_user}
  let (:f3) {create :fact, created_by: user.graph_user}

  let (:ch_heavy) do
    ch_heavy = create :channel, created_by: user.graph_user
    [f1,f2,f3].each do |f|
      Interactors::Channels::AddFact.new(f, ch_heavy, no_current_user: true).call
    end
    ch_heavy
  end

  let(:ch_light) { create :channel, created_by: user.graph_user }

  describe "#index" do
    it "as json should be successful" do
      ch_light
      authenticate_user!(user)
      ability.should_receive(:can?).with(:index, Channel).and_return(true)
      get :index, username: user.username, format: 'json'
      response.should be_success
    end

    it "should render the same json as previously (regression check)" do
      Timecop.freeze Time.local(1995, 4, 30, 15, 35, 45)
      FactoryGirl.reload # hack because of fixture in check
      ch_heavy
      authenticate_user!(user)
      ability.should_receive(:can?).with(:index, Channel).and_return(true)
      get :index, username: user.username, format: 'json'
      response.should be_success

      response_body = response.body.to_s
      # strip created_by mongo id, since otherwise comparison will always fail
      response_body.gsub!(/"id":\s*"[^"]*"/, '"id": "<STRIPPED>"')
      Approvals.verify(response_body, format: :json, name: 'channels.json should keep the same content')
    end

    it "as bogus user should redirect to Terms of Service page" do
      authenticate_user!(nonnda_user)
      get :index, username: user.username
      response.should redirect_to(tos_path)
    end
  end

  describe "#facts" do
    it "should render" do
      authenticate_user!(user)
      should_check_can :show, ch_heavy
      get :facts, username: user.username, id: ch_heavy.id, :format => :json
      response.should be_success
    end

    it "json should stay the same" do
      # not doing the whole time cop thing, since the dates in the
      # timestamped set are generated by redis (This is: Jan's guess (TM))
      FactoryGirl.reload # hack because of fixture in check

      authenticate_user!(user)
      should_check_can :show, ch_heavy

      get :facts, username: user.username, id: ch_heavy.id, :format => :json
      response.should be_success

      response_body = response.body.to_s
      # strip mongo id, since otherwise comparison will always fail
      response_body.gsub!(/"id":\s*"[^"]*"/, '"id": "<STRIPPED>"')
      response_body.gsub!(/"timestamp":\s*\d*\.0/, '"timestamp": 0')
      Approvals.verify(response_body, format: :json, name: 'channels#facts should keep the same content')
    end
  end

  describe "#show" do
    it "a channel should be succesful" do
      authenticate_user!(user)
      should_check_can :access, Ability::FactlinkWebapp
      should_check_can :show, ch_light
      get :show, username: user.username, id: ch_light.id
      response.should be_success
    end

    it "a channel as json should be succesful" do
      authenticate_user!(user)
      should_check_can :show, ch_heavy
      ability.should_receive(:can?).with(:index, Channel).and_return true
      get :show, username: user.username, id: ch_heavy.id, format: 'json'
      response.should be_success
    end

    it "should escape html in fields" do
      authenticate_user!(user)
      ch = create(:channel)
      ch.title = "baas<xss> of niet"
      ch.created_by = user.graph_user
      ch.save

      should_check_can :access, Ability::FactlinkWebapp
      should_check_can :show, ch
      get :show, :id => ch.id, :username => user.username

      response.body.should_not match(/<xss>/)
    end
  end

  describe "#follow" do
    it "should call the channels/follow interactor" do
      authenticate_user!(user)

      channel_id = '1a'
      channel = mock

      controller.should_receive(:interactor).
        with(:'channels/follow', channel_id).
        and_return(channel)

      post :follow, id: channel_id

      response.should be_success
    end
  end
end
